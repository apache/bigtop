/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.ajoberstar.grgit.*
import groovy.json.JsonOutput

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath 'org.ajoberstar:grgit:0.4.1'
    // To handle symbolic links when cloning git repos, the jgit.java7 jar
    // must be added to the classpath.
    classpath 'org.eclipse.jgit:org.eclipse.jgit.java7:3.6.2.201501210735-r'
  }
}

apply plugin: 'java'
apply plugin: 'groovy'

def PACKAGES_GROUP = 'package'

final String VERBOSE = "verbose"
final String BOM = "$rootDir/bigtop.bom"
def final config

//HashMap <String, String>
def BOM_map = [
    BASE_DIR:       projectDir.absolutePath,
    BUILD_DIR:      projectDir.absolutePath + "/build",
    OUTPUT_DIR:     projectDir.absolutePath + "/output",
    DIST_DIR:       projectDir.absolutePath + "/dist",
    DL_DIR:         projectDir.absolutePath + "/dl",
    BIGTOP_BOM:     '',
    BIGTOP_BUILD_STAMP: 1
]

def final BIGTOP_VERSION = 'BIGTOP_VERSION'
def final BIGTOP_BOM_VERSIONS = 'BIGTOP_BOM'

def final BASE_DIR = BOM_map['BASE_DIR']
def final REPO_DIR = "${BOM_map['BASE_DIR']}/bigtop-repos"
def final BUILD_DIR = BOM_map['BUILD_DIR']
def final OUTPUT_DIR = BOM_map['OUTPUT_DIR']
def final DIST_DIR = BOM_map['DIST_DIR']
def final DL_DIR = BOM_map['DL_DIR']
def final BIGTOP_BUILD_STAMP = System.getenv('BIGTOP_BUILD_STAMP') ?: BOM_map['BIGTOP_BUILD_STAMP']

def targets = []
def components = []

// Package building and logic around it

def touchTargetFile = { fileName ->
  // to comply with make build
  GFileUtils.touch new File(fileName)
}
def ifExists = { url ->
  if (url == null) return
  URLConnection uCon = new URL(url).openConnection()
  return (uCon as HttpURLConnection).responseCode == 200
}
def getDate() {
  new Date().format('E, dd MMM yyyy HH:mm:ss Z')
}

def nativePackaging = {
  def devNull = new org.apache.bigtop.NullOutputStream()
  def result = exec {
    commandLine "/bin/bash", "-c",
    """dpkg-query -S /bin/sh && exit 1
       rpm -qf /bin/sh && exit 2
       exit 0
    """
    ignoreExitValue true
    errorOutput devNull
    standardOutput devNull
  }
  [false, "deb", "rpm"][result.getExitValue()]
}.call()

task "packages-help" (description: "All package build related tasks information", group: PACKAGES_GROUP) << {
  targets.each { target ->
    println (target + "\n\t[" + tasks.findAll { alltask -> alltask.name.startsWith(target)}*.name.join(", ") + "]")
  }
}

task "bom-json" (description: "List the components of the stack in json format") << {
  def componentObjects = components.sort().collect {
    [
      name: [
        project: BOM_map[it + '_NAME'],
        pkg: BOM_map[it + '_PKG'],
        relNotes: BOM_map[it + '_RELNOTES'],
      ],
      tarball: [
        destination: BOM_map[it + '_TARBALL_DESTINATION'],
        source: BOM_map[it + '_TARBALL_SOURCE'],
      ],
      url: [
        site: BOM_map[it + '_URL_SITE'],
        archive: BOM_map[it + '_URL_ARCHIVE'],
      ],
      version: [
        base: BOM_map[it + '_VERSION_BASE'],
        pkg: BOM_map[it + '_VERSION_PKG'],
        release: BOM_map[it + '_VERSION_RELEASE'],
      ],
      git: [
         repo: BOM_map[it + '_GIT_REPO'],
         ref: BOM_map[it + '_GIT_REF'],
         dir: BOM_map[it + '_GIT_DIR'],
      ]
    ]
  }
  def fullDefinition = [
    version: BOM_map[BIGTOP_VERSION],
    components: componentObjects
  ]
  def json = JsonOutput.toJson(fullDefinition)
  println JsonOutput.prettyPrint(json)
}

task "all-components" (description: "List the components of the stack") << {
  println "${project.name} ${BOM_map[BIGTOP_VERSION]} stack includes the following components"
  components.sort().each { comp ->
    println sprintf ('\t%1$s %2$s', comp.toLowerCase().padRight(20), BOM_map[comp + "_VERSION_BASE"].padLeft(15))
  }
}

def genTasks = { target, variable ->
  Task t = task "${target}-download" (dependsOn: "${target}_vardefines",
      description: "Download $target artifacts",
      group: PACKAGES_GROUP) << {

    def final TARBALL_SRC = BOM_map[variable + '_TARBALL_SOURCE']
    def final DOWNLOAD_DST = BOM_map[variable + '_DOWNLOAD_DST']
    def final DOWNLOAD_URL = BOM_map[variable + '_DOWNLOAD_URL']

    def final GIT_REPO = BOM_map[variable + '_GIT_REPO']
    def final GIT_REF = BOM_map[variable + '_GIT_REF']
    def final GIT_DIR = BOM_map[variable + '_GIT_DIR']

    if (!DOWNLOAD_DST)
      return

    mkdir(DL_DIR)
    if (TARBALL_SRC?.isEmpty() || new File(DOWNLOAD_DST)?.exists() || new File(BOM_map[variable + '_TARGET_DL'])?.exists()) {
      println "\tFile $DOWNLOAD_DST appears to be already downloaded. Exiting..."
      return
    }
    if (GIT_REPO && GIT_REF) {
      def dir = GIT_DIR
      if (dir == null || dir.isEmpty()) {
        dir = TARBALL_SRC.substring(0, TARBALL_SRC.lastIndexOf(".t"))
      }
      delete("${DL_DIR}/${dir}")
      Grgit.clone(
        uri: GIT_REPO,
        refToCheckout: GIT_REF,
        dir: new File("${DL_DIR}/${dir}")
      )
      delete("${DL_DIR}/${dir}/.git")
      exec {
        workingDir DL_DIR
        commandLine "tar -czf ${TARBALL_SRC} ${dir}".split()
      }
      delete("${DL_DIR}/${dir}")
    }
    else {
      download {
        src DOWNLOAD_URL
        dest DOWNLOAD_DST
      }
    }
    touchTargetFile(BOM_map[variable + '_TARGET_DL'])
  }
  task "${target}-tar" (dependsOn: ["${target}_vardefines", "${target}-download"],
      description: "Preparing a tarball for $target artifacts",
      group: PACKAGES_GROUP) << {
    if (new File(BOM_map[variable + '_TARGET_TAR'])?.exists()) {
      println "\tNothing to do. Exiting..."
      return
    }
    def final TAR_DIR = BOM_map[variable + '_TAR_DIR']
    def final TARBALL_SRC = BOM_map[variable + '_TARBALL_SOURCE'] ?: ""
    def final DOWNLOAD_DST = BOM_map[variable + '_DOWNLOAD_DST'] ?: ""
    def final SEED_TAR = BOM_map[variable + '_SEED_TAR']

    delete(TAR_DIR); mkdir(TAR_DIR)

    if (TARBALL_SRC.empty || TARBALL_SRC.endsWith('.zip')) {
      if (TARBALL_SRC.empty) {
        // if no tar file needed (i.e. bigtop-utils)
        // create some contents to pack later
        copy {
          from 'LICENSE'
          into TAR_DIR
        }
      } else {
        // i.e. a ZIP file
        exec {
          workingDir TAR_DIR
          commandLine "unzip $DOWNLOAD_DST".split(' ')
        }
        def unpacked = new File(TAR_DIR)
        // check wether we have to move contents one level up
        if (unpacked.list().size() == 1) {
          def TOP_LEVEL_DIR = unpacked.list()[0]
          new File("$TAR_DIR/$TOP_LEVEL_DIR").list({ d, f ->
            (f != "." && f != "..")}).each { f ->
              new File("$TAR_DIR/$TOP_LEVEL_DIR/$f").renameTo("$TAR_DIR/$f")
          }
          delete(TOP_LEVEL_DIR)
        }
      }
      // create SEED_TAR
      exec {
        workingDir "$TAR_DIR/.."
        commandLine "tar -czf $SEED_TAR ${new File("$TAR_DIR/..").list().join(' ')}".split(' ')
      }
    } else {
      println "Copy $DOWNLOAD_DST to $SEED_TAR"
      copy {
        from DOWNLOAD_DST
        into BOM_map['BUILD_DIR'] + "/$target/tar/"
        rename TARBALL_SRC, SEED_TAR
      }
    }
    touchTargetFile(BOM_map[variable + '_TARGET_TAR'])
  }

  // Keeping the reference to deb task to be used later for correct sequencing
  Task tdeb = task "$target-deb"(dependsOn: "${target}-sdeb",
      description: "Building DEB for $target artifacts",
      group: PACKAGES_GROUP) << {
    if (new File(BOM_map[variable + '_TARGET_DEB'])?.exists()) {
      println "\tNothing to do. Exiting..."
      return
    }
    def final PKG_NAME = BOM_map[variable + '_PKG']
    def final PKG_RELEASE = BOM_map[variable + '_PKG_RELEASE']
    def final PKG_VERSION = BOM_map[variable + '_VERSION_PKG']
    def final PKG_OUTPUT_DIR = BOM_map[variable + '_OUTPUT_DIR']
    def final BASE_VERSION = BOM_map[variable + '_VERSION_BASE']
    def final SRCDEB = "${PKG_NAME}_$PKG_VERSION-${BIGTOP_BUILD_STAMP}.dsc"

    exec {
      workingDir PKG_OUTPUT_DIR
      commandLine "dpkg-source -x $SRCDEB".split(' ')
    }
// Order of debuild parameters is important; hence specifying explicitely rather
// than in an array of args
    def command = """debuild \
--preserve-envvar PATH \
--preserve-envvar JAVA32_HOME \
--preserve-envvar JAVA64_HOME \
--preserve-envvar FORREST_HOME \
--preserve-envvar MAVEN3_HOME \
--preserve-envvar MAVEN_OPTS \
--preserve-envvar JAVA_HOME \
--set-envvar=${variable}_BASE_VERSION=$BASE_VERSION \
--set-envvar=${variable}_VERSION=$PKG_VERSION \
--set-envvar=${variable}_RELEASE=$BIGTOP_BUILD_STAMP \
-uc -us -b
"""
    exec {
      workingDir "$PKG_OUTPUT_DIR/$PKG_NAME-$PKG_VERSION"
      commandLine command.split(' ')
    }
    exec {
      workingDir "$PKG_OUTPUT_DIR"
      commandLine 'rm','-rf',"$PKG_NAME-$PKG_VERSION"
    }
    touchTargetFile(BOM_map[variable + '_TARGET_DEB'])
  }
  // Guarantee that tasks are ran in the order set by BOM file
  if (targets.size() > 0)
    tdeb.mustRunAfter "${targets.get(targets.size() - 1)}-deb"
   task "$target-sdeb" (dependsOn: ["${target}_vardefines",  "${target}-tar"],
      description: "Building SDEB for $target artifacts",
      group: PACKAGES_GROUP
  ) << {
    if (new File(BOM_map[variable + '_TARGET_SDEB'])?.exists()) {
      println "\tNothing to do. Exiting..."
      return
    }
    def final PKG_BUILD_DIR = BOM_map[variable + '_BUILD_DIR']
    def final NAME = BOM_map[variable + '_NAME']
    def final PKG_NAME = BOM_map[variable + '_PKG']
    def final SEED_TAR = BOM_map[variable + '_SEED_TAR']
    def final PKG_VERSION = BOM_map[variable + '_VERSION_PKG']
    def final PKG_OUTPUT_DIR = BOM_map[variable + '_OUTPUT_DIR']
    delete ("$PKG_BUILD_DIR/deb")
    def final DEB_BLD_DIR = "$PKG_BUILD_DIR/deb/$NAME-${PKG_VERSION}"
    def final DEB_PKG_DIR = "$PKG_BUILD_DIR/deb/$PKG_NAME-${PKG_VERSION}-${BIGTOP_BUILD_STAMP}"
    mkdir (DEB_BLD_DIR)
    copy {
      from SEED_TAR
      into "$PKG_BUILD_DIR/deb/"
      rename BOM_map[variable + '_TARBALL_DESTINATION'], "${PKG_NAME}_${PKG_VERSION}.orig.tar.gz"
    }
    exec {
      workingDir DEB_BLD_DIR
      commandLine "tar --strip-components 1 -xf $DEB_BLD_DIR/../${PKG_NAME}_${PKG_VERSION}.orig.tar.gz".split(' ')
    }
    fileTree ("${BASE_DIR}/bigtop-packages/src/deb/$NAME") {
      include '**/*'
    }.copy { into "$DEB_BLD_DIR/debian" }
    copy {
      from "${BASE_DIR}/bigtop-packages/src/templates/init.d.tmpl"
      into "$DEB_BLD_DIR/debian"
    }
    fileTree ("$BASE_DIR/bigtop-packages/src/common/$NAME") {
      include '**/*'
    }.copy { into "$DEB_BLD_DIR/debian" }
    // Prepeare bom file with all the versions
    def bomWriter = new File("$DEB_BLD_DIR/debian/bigtop.bom").newWriter()
    BOM_map[BIGTOP_BOM_VERSIONS].split(" ").each { bomWriter << "$it\n"}
    bomWriter.close()
    // Create changelog
    def changelog = new File("$DEB_BLD_DIR/debian/changelog").newWriter()
    changelog << "$PKG_NAME ($PKG_VERSION-$BIGTOP_BUILD_STAMP) stable; urgency=low\n"
    changelog << "  Clean build\n"
    changelog << " -- Bigtop <dev@bigtop.apache.org>  ${getDate()}\n"
    changelog.close()

    // Move patches and create "series"
    def patches = new File( "$DEB_BLD_DIR/debian").list({ d, f -> f ==~ /patch.*diff/}).sort()
    if (patches.size() > 0) {
      mkdir("$DEB_BLD_DIR/debian/patches")
      def seriesWriter = new File("$DEB_BLD_DIR/debian/patches/series").newWriter()
      patches.each { f ->
        def res = new File("$DEB_BLD_DIR/debian/$f").renameTo( "$DEB_BLD_DIR/debian/patches/$f")
        seriesWriter << "$f\n"
      }
      seriesWriter.close()
    }
    // Deleting obsolete files
    delete fileTree (dir: "$DEB_BLD_DIR/debian", includes: ['*.ex', '*.EX', '*.~'])
    // Creating source package
    exec {
      workingDir DEB_BLD_DIR
      commandLine "dpkg-buildpackage -uc -us -sa -S".split(' ')
    }
    mkdir(PKG_OUTPUT_DIR)
    fileTree (dir: "$DEB_PKG_DIR/..", includes: ['*.dsc', '*.diff.gz', '*.debian.tar.gz', '*.debian.tar.xz', "*_source.changes", "*.orig.tar.gz" ]).copy {
      into PKG_OUTPUT_DIR
    }
    touchTargetFile(BOM_map[variable + '_TARGET_SDEB'])
  }

  // Keeping the reference to task to be used later for correct sequencing
  Task trpm = task "$target-rpm" (dependsOn: ["${target}-srpm"],
      description: "Building RPM for $target artifacts",
      group: PACKAGES_GROUP) << {
    if (new File(BOM_map[variable + '_TARGET_RPM'])?.exists()) {
      println "\tNothing to do. Exiting..."
      return
    }
    def final PKG_BUILD_DIR = BOM_map[variable + '_BUILD_DIR']
    def final NAME = BOM_map[variable + '_NAME']
    def final PKG_NAME = BOM_map[variable + '_PKG']
    def final PKG_OUTPUT_DIR = BOM_map[variable + '_OUTPUT_DIR']
    def final PKG_VERSION = BOM_map[variable + '_VERSION_PKG']
    def final BASE_VERSION = BOM_map[variable + '_VERSION_BASE']
    def RELEASE_DIST = "rpmbuild --eval '%{?dist}' 2>/dev/null".execute().text.trim().replaceAll("'",'')
    def SRCRPM="$PKG_OUTPUT_DIR/$PKG_NAME-${PKG_VERSION}-$BIGTOP_BUILD_STAMP${RELEASE_DIST}.src.rpm"

    def command = [
        '--define', "_topdir $PKG_BUILD_DIR/rpm/",
        '--define', "${NAME}_base_version $BASE_VERSION",
        '--define', "${NAME}_version ${PKG_VERSION}",
        '--define', "${NAME}_release ${BIGTOP_BUILD_STAMP}%{?dist}",
        '--rebuild', SRCRPM,
    ]
    exec {
      workingDir BASE_DIR
      executable 'rpmbuild'
      args command
    }
    fileTree ("$PKG_BUILD_DIR/rpm/RPMS") {
      include '**/*'
    }.copy { into PKG_OUTPUT_DIR }
    touchTargetFile(BOM_map[variable + '_TARGET_RPM'])
  }
  // Guarantee that tasks are ran in the order set by BOM file
  if (targets.size() > 0)
    trpm.mustRunAfter "${targets.get(targets.size() - 1)}-rpm"
  task "$target-srpm" (dependsOn: ["${target}_vardefines" , "${target}-tar"],
      description: "Building SRPM for $target artifacts",
      group: PACKAGES_GROUP) << {
    if (new File(BOM_map[variable + '_TARGET_SRPM'])?.exists()) {
      println "\tNothing to do. Exiting..."
      return
    }
    def final NAME = BOM_map[variable + '_NAME']
    def final PKG_NAME = BOM_map[variable + '_PKG']
    def final PKG_NAME_FOR_PKG = BOM_map[variable + '_NAME'].replaceAll("-", "_")
    def final PKG_BUILD_DIR = BOM_map[variable + '_BUILD_DIR']
    def final SEED_TAR = BOM_map[variable + '_SEED_TAR']
    def final PKG_VERSION = BOM_map[variable + '_VERSION_PKG']
    def final BASE_VERSION = BOM_map[variable + '_VERSION_BASE']
    def final PKG_OUTPUT_DIR = BOM_map[variable + '_OUTPUT_DIR']
    delete ("$PKG_BUILD_DIR/rpm")
    ['INSTALL','SOURCES','BUILD','SRPMS','RPMS'].each { rpmdir ->
      mkdir("$PKG_BUILD_DIR/rpm/$rpmdir")
    }
    fileTree ("${BASE_DIR}/bigtop-packages/src/rpm/$NAME") {
      include '**/*'
    }.copy { into "$PKG_BUILD_DIR/rpm" }
    copy {
      from SEED_TAR
      into "$PKG_BUILD_DIR/rpm/SOURCES"
    }
    copy {
      from "${BASE_DIR}/bigtop-packages/src/templates/init.d.tmpl"
      into "$PKG_BUILD_DIR/rpm/SOURCES"
    }
    fileTree ("$BASE_DIR/bigtop-packages/src/common/$NAME") {
      include '**/*'
    }.copy { into "$PKG_BUILD_DIR/rpm/SOURCES" }
    // Writing bigtop.bom files with all the versions
    def bomWriter = new File("$PKG_BUILD_DIR/rpm/SOURCES/bigtop.bom").newWriter()
    BOM_map[BIGTOP_BOM_VERSIONS].split(" ").each { bomWriter << "$it\n"}
    bomWriter.close()

    def specFileName = "${PKG_BUILD_DIR}/rpm/SPECS/${NAME}.spec"
    def specTmpFileName = "${PKG_BUILD_DIR}/rpm/SPECS/tmp_${NAME}.spec"
    def specFile = new File(specFileName)
    def specWriter = new File(specTmpFileName).newWriter()
    def patches = new File("${PKG_BUILD_DIR}/rpm/SOURCES").list({ d, f -> f ==~ /patch.*diff/}).sort()
    specFile.eachLine { line ->
      if (line.startsWith("#BIGTOP_PATCH_FILES")) {
        def patchNum = 0
        patches.each { p ->
          specWriter << "Patch$patchNum: $p\n"
          patchNum++
        }
      } else {
        if (line.startsWith("#BIGTOP_PATCH_COMMANDS")) {
          def patchNum = 0
          patches.each { p ->
            specWriter << "%patch$patchNum -p1\n"
            patchNum++
          }
        } else {
          specWriter << "$line\n"
        }
      }
    }
    specWriter.close()
    specFile.delete()
    new File(specTmpFileName).renameTo(specFileName)

    def command = [
        '--define', "_topdir $PKG_BUILD_DIR/rpm/",
        '--define', "${PKG_NAME_FOR_PKG}_base_version $BASE_VERSION",
        '--define', "${PKG_NAME_FOR_PKG}_version ${PKG_VERSION}",
        '--define', "${PKG_NAME_FOR_PKG}_release ${BIGTOP_BUILD_STAMP}%{?dist}",
        '-bs', '--nodeps', "--buildroot=${PKG_BUILD_DIR}/rpm/INSTALL",
        specFileName,
    ]
    exec {
      workingDir BASE_DIR
      executable 'rpmbuild'
      args command
    }
    mkdir(PKG_OUTPUT_DIR)
    def RELEASE_DIST = "rpmbuild --eval '%{?dist}' 2>/dev/null".execute().text.trim().replaceAll("'",'')
    copy {
      from "$PKG_BUILD_DIR/rpm/SRPMS/${PKG_NAME}-${PKG_VERSION}-${BIGTOP_BUILD_STAMP}${RELEASE_DIST}.src.rpm"
      into PKG_OUTPUT_DIR
    }
    touchTargetFile(BOM_map[variable + '_TARGET_SRPM'])
  }
  if (nativePackaging) {
    task "$target-pkg" (dependsOn: "$target-$nativePackaging",
        description: "Invoking a native binary packaging target $nativePackaging",
        group: PACKAGES_GROUP) << {
    }
    task "$target-spkg" (dependsOn: "$target-s$nativePackaging",
        description: "Invoking a native binary packaging target s$nativePackaging",
        group: PACKAGES_GROUP) << {
    }
  }
  task "$target-version" (description: "Show version of $target component", group: PACKAGES_GROUP) << {
    println "Base: ${BOM_map[variable + '_VERSION_BASE']}"
  }
  task "${target}_vardefines" << {
    BOM_map[variable + '_NAME'] = target
    if (!BOM_map[variable + '_PKG']) {
      BOM_map[variable + '_PKG'] = BOM_map[variable + '_NAME']
    }
    if (!BOM_map[variable + '_VERSION_PKG']) {
      BOM_map[variable + '_VERSION_PKG'] = BOM_map[variable + '_VERSION_BASE']
    }
    BOM_map[variable + '_PKG_RELEASE'] = '1'

    BOM_map[variable + '_BUILD_DIR'] = BOM_map['BUILD_DIR'] + "/$target"
    BOM_map[variable + '_OUTPUT_DIR'] = BOM_map['OUTPUT_DIR'] + "/$target"
    BOM_map[variable + '_SOURCE_DIR'] = BOM_map['BUILD_DIR'] + "/source"
    BOM_map[variable + '_TAR_DIR'] = BOM_map['BUILD_DIR'] + "/$target/tar/${target}-${BOM_map[variable + '_VERSION_BASE']}"
    BOM_map[variable + '_SEED_TAR'] = BOM_map['BUILD_DIR'] + "/$target/tar/" + BOM_map[variable + '_TARBALL_DESTINATION']

    BOM_map[variable + '_DOWNLOAD_URL'] =
        (BOM_map[variable + '_URL_SITE'] != null && BOM_map[variable + '_TARBALL_SOURCE'] != null) ?
            BOM_map[variable + '_URL_SITE'] + '/' + BOM_map[variable + '_TARBALL_SOURCE'] : null
    BOM_map[variable + '_DOWNLOAD_DST'] = (BOM_map[variable + '_TARBALL_SOURCE'] != null) ?
        DL_DIR + '/' + BOM_map[variable + '_TARBALL_SOURCE'] : null

    // test that the download url will return http 200.  If it does not, use the ARCHIVE url instead of the MIRROR SITE url
    if (!ifExists(BOM_map[variable + '_DOWNLOAD_URL'])) {
      BOM_map[variable + '_DOWNLOAD_URL'] = BOM_map[variable + '_URL_ARCHIVE'] + '/' + BOM_map[variable + '_TARBALL_SOURCE']
    }

    BOM_map[variable + '_TARGET_DL']  = BOM_map[variable + '_BUILD_DIR'] + '/.download'
    BOM_map[variable + '_TARGET_TAR']  = BOM_map[variable + '_BUILD_DIR'] + '/.tar'
    BOM_map[variable + '_TARGET_SRPM']  = BOM_map[variable + '_BUILD_DIR'] + '/.srpm'
    BOM_map[variable + '_TARGET_RPM']  = BOM_map[variable + '_BUILD_DIR'] + '/.rpm'
    BOM_map[variable + '_TARGET_SDEB']  = BOM_map[variable + '_BUILD_DIR'] + '/.sdeb'
    BOM_map[variable + '_TARGET_DEB']  = BOM_map[variable + '_BUILD_DIR'] + '/.deb'
    BOM_map[variable + '_TARGET_RELNOTES']  = BOM_map[variable + '_BUILD_DIR'] + '/.relnotes'

    if (System.getProperty(VERBOSE)) {
      BOM_map.keySet().findAll{ it.startsWith (variable) }. each { k ->
        println "$k ${BOM_map.get(k)}"
      }
    }
  }

  task "$target-info" (dependsOn: "${target}_vardefines",
      description: "Info about $target component build",
      group: PACKAGES_GROUP) << {
    println "Info for package $target"
    println "  Will download from URL: ${BOM_map[variable + '_DOWNLOAD_URL']}"
    println "  To destination file: ${BOM_map[variable + '_DOWNLOAD_DST']}"
    println "  Then unpack into ${BOM_map[variable + '_SOURCE_DIR']}"
    println "  And create a seed tarball ${BOM_map[variable + '_SEED_TAR']}"

    println "Version: " + BOM_map[variable + '_VERSION_BASE']
    //TODO more about stamping
  }
  task "$target-relnotes" (description: "Preparing release notes for $target. No yet implemented!!!", group: PACKAGES_GROUP)<< {
  }
  task "$target-clean" (dependsOn: "${target}_vardefines",
      description: "Removing $target component ${BOM_map[variable + '_BUILD_DIR']} and ${BOM_map[variable + '_OUTPUT_DIR']}",
      group: PACKAGES_GROUP) << {
    delete(BOM_map[variable + '_BUILD_DIR'])
    delete(BOM_map[variable + '_OUTPUT_DIR'])
  }
  task "$target-help" (description: "List of available tasks for $target", group: PACKAGES_GROUP) << {
    println (target + "\n\t[" + tasks.findAll { alltask -> alltask.name.startsWith(target)}*.name.join(", ") + "]")
  }
}

def readBOM = {
  config = new ConfigSlurper().parse(new URL("file:$BOM"))
  doValidateBOM(config)
  BOM_map[BIGTOP_VERSION] = config.bigtop.version
  config.bigtop.apache.each { name, value ->
      BOM_map[name] = value
  }
  config.bigtop.stack.each { name, comp ->
    comp.toProperties(name).each {k, v ->
      BOM_map[(k.replaceAll("\\.", "_").toUpperCase())] = v
    }
  }
  config.bigtop.components.each { label, comp ->
    // while closure name in the component's config could include '-'; the prefix in the BOM_map shouldn't
    def prefix = comp.name.replaceAll("\\-", "_").toUpperCase()
//  TODO?: To avoid changing every bit of the builds logic, let's stick to the old naming format
    comp.toProperties(prefix).each {comp_config_key, comp_config_value ->
      BOM_map[(comp_config_key.replaceAll("\\.", "_").toUpperCase())] = comp_config_value
    }
    genTasks(comp.name, prefix)
    targets.add(comp.name)
    components.add(prefix)
  }
}

// Let's enforce some of the configuration requirements
private void doValidateBOM(config) {
  assert config.bigtop.version
  assert config.bigtop.stack.jdk
  assert config.bigtop.stack.scala
  assert config.bigtop.apache.size() != 0
}

// We need to make sure that all dynamic tasks are available for invocation
project.afterEvaluate {
  readBOM()
  def bomVersions = ""
  // Versions need to be preserved for more than just component:
  //  - there are JDK version requirement
  //  - possibly more in the future
  BOM_map.keySet().findAll { it ==~ /.*VERSION_BASE/ }.each { version_base ->
    bomVersions += "${version_base.replaceAll('_BASE', '')}=${BOM_map[version_base]} "
  }
  BOM_map[BIGTOP_BOM_VERSIONS] = bomVersions
  if (System.getProperty(VERBOSE))println "BIGTOP_BOM_VERSIONS:\n${BOM_map[BIGTOP_BOM_VERSIONS]}"
  if (System.getProperty(VERBOSE))println "Full content:\n${BOM_map}"
  // Putting all targets of different types into one common target
  task "srpm" (dependsOn: tasks.findAll { alltask -> alltask.name.endsWith("-srpm")}*.name,
      description: "Build all SRPM packages for the stack components",
      group: PACKAGES_GROUP
  ) << { }
  task "rpm" (dependsOn: tasks.findAll { alltask -> alltask.name.endsWith("-rpm")}*.name,
      description: "Build all RPM packages for the stack",
      group: PACKAGES_GROUP
  ) << { }
  task "sdeb" (dependsOn: tasks.findAll { alltask -> alltask.name.endsWith("-sdeb")}*.name,
      description: "Build all SDEB packages for the stack components",
      group: PACKAGES_GROUP
  ) << { }
  task "deb" (dependsOn: tasks.findAll { alltask -> alltask.name.endsWith("-deb")}*.name,
      description: "Build all DEB packages for the stack components",
      group: PACKAGES_GROUP
  ) << { }

  task allclean (dependsOn: [clean, tasks.findAll { alltask -> alltask.name.endsWith("-clean")}*.name],
      description: "Removing $BUILD_DIR, $OUTPUT_DIR, and $DIST_DIR.\n\t\t" +
        "Cleaning all components' build and output directories.",
      group: PACKAGES_GROUP) << {
    delete (BUILD_DIR)
    delete (OUTPUT_DIR)
    delete (DIST_DIR)
  }
  task realclean (dependsOn: allclean,
      description: "Removing $BUILD_DIR, $OUTPUT_DIR, $DIST_DIR, and $DL_DIR",
      group: PACKAGES_GROUP) << {
    delete (DL_DIR)
  }
}

task "apt" (
    description: "Creating APT repository",
    group: PACKAGES_GROUP) << {

  delete ( "$OUTPUT_DIR/apt")
  mkdir ("$OUTPUT_DIR/apt/conf")

  copy {
    from "$REPO_DIR/apt/distributions"
    into "$OUTPUT_DIR/apt/conf"
  }
  fileTree (OUTPUT_DIR) {
    include "*/*.changes"
  }.each  { changeFile ->
    exec {
      workingDir BUILD_DIR
      commandLine "reprepro -Vb $OUTPUT_DIR/apt include bigtop $changeFile".split(' ')
    }
  }
}

task "yum" (
    description: "Creating YUM repository",
    group: PACKAGES_GROUP) << {
  delete ( "$OUTPUT_DIR/repodata")
  exec {
    workingDir BUILD_DIR
    commandLine "createrepo -o $OUTPUT_DIR $OUTPUT_DIR".split(' ')
  }
}
